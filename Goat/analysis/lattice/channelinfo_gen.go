// Code generated by generate-product.go for ChannelInfo. DO NOT EDIT.

package lattice

import (
	i "Goat/utils/indenter"
)

type ChannelInfo struct {
	element
	product Product
}

func (m ChannelInfo) ChannelInfo() ChannelInfo {
	return m
}

func (w ChannelInfo) String() string {
	fields := []struct {
		name  string
		value Element
	}{
		{"Capacity", w.Capacity()},
		{"Open?", w.Status()},
		{"Buffer (flat)", w.BufferFlat()},
		{"Buffer (interval)", w.BufferInterval()},
		{"Payload", w.Payload()},
	}

	strs := make([]func() string, 0, len(fields))

	for _, field := range fields {
		if !field.value.eq(field.value.Lattice().Bot()) {
			strs = append(strs, (func(name string, value Element) func() string {
				return func() string {
					return colorize.Field(name) + ": " + value.String()
				}
			})(field.name, field.value))
		}
	}

	if len(strs) == 0 {
		return colorize.Element("⊥")
	}

	return i.Indenter().Start("{").NestThunkedSep(",", strs...).End("}")
}

func (w ChannelInfo) Height() int {
	return w.product.Height()
}

func (m ChannelInfo) Eq(o Element) bool {
	checkLatticeMatch(m.lattice, o.Lattice(), "=")
	return m.eq(o)
}

func (m ChannelInfo) eq(o Element) bool {
	switch o := o.(type) {
	case ChannelInfo:
		return m.product.eq(o.product)
	case *LiftedBot:
		return false
	case *DroppedTop:
		return false
	default:
		panic(errInternal)
	}
}

func (m ChannelInfo) Geq(o Element) bool {
	checkLatticeMatch(m.lattice, o.Lattice(), "⊒")
	return m.geq(o)
}

func (m ChannelInfo) geq(o Element) bool {
	switch o := o.(type) {
	case ChannelInfo:
		return m.product.geq(o.product)
	case *LiftedBot:
		return true
	case *DroppedTop:
		return false
	default:
		panic(errInternal)
	}
}

func (m ChannelInfo) Leq(o Element) bool {
	checkLatticeMatch(m.lattice, o.Lattice(), "⊑")
	return m.leq(o)
}

func (m ChannelInfo) leq(o Element) bool {
	switch o := o.(type) {
	case ChannelInfo:
		return m.product.leq(o.product)
	case *LiftedBot:
		return false
	case *DroppedTop:
		return true
	default:
		panic(errInternal)
	}
}

func (m ChannelInfo) Join(o Element) Element {
	checkLatticeMatch(m.Lattice(), o.Lattice(), "⊔")
	return m.join(o)
}

func (m ChannelInfo) MonoJoin(o ChannelInfo) ChannelInfo {
	m.product = m.product.MonoJoin(o.product)
	return m
}

func (m ChannelInfo) join(o Element) Element {
	switch o := o.(type) {
	case ChannelInfo:
		return m.MonoJoin(o)
	case *LiftedBot:
		return m
	case *DroppedTop:
		return o
	default:
		panic(errInternal)
	}
}

func (m ChannelInfo) Meet(o Element) Element {
	checkLatticeMatch(m.lattice, o.Lattice(), "⊓")
	return m.meet(o)
}

func (m ChannelInfo) MonoMeet(o ChannelInfo) ChannelInfo {
	m.product = m.product.MonoMeet(o.product)
	return m
}

func (m ChannelInfo) meet(o Element) Element {
	switch o := o.(type) {
	case ChannelInfo:
		return m.MonoMeet(o)
	case *LiftedBot:
		return o
	case *DroppedTop:
		return m
	default:
		panic(errInternal)
	}
}

func (w ChannelInfo) Capacity() FlatElement {
	return w.product.Get(0).Flat()
}

func (w ChannelInfo) UpdateCapacity(value FlatElement) ChannelInfo {
	w.product = w.product.Update(0, value)
	return w
}

func (w ChannelInfo) Status() FlatElement {
	return w.product.Get(1).Flat()
}

func (w ChannelInfo) UpdateStatus(value FlatElement) ChannelInfo {
	w.product = w.product.Update(1, value)
	return w
}

func (w ChannelInfo) BufferFlat() FlatElement {
	return w.product.Get(2).Flat()
}

func (w ChannelInfo) UpdateBufferFlat(value FlatElement) ChannelInfo {
	w.product = w.product.Update(2, value)
	return w
}

func (w ChannelInfo) BufferInterval() Interval {
	return w.product.Get(3).Interval()
}

func (w ChannelInfo) UpdateBufferInterval(value Interval) ChannelInfo {
	w.product = w.product.Update(3, value)
	return w
}

func (w ChannelInfo) Payload() AbstractValue {
	return w.product.Get(4).AbstractValue()
}

func (w ChannelInfo) UpdatePayload(value AbstractValue) ChannelInfo {
	w.product = w.product.Update(4, value)
	return w
}

func _checkChannelInfo(el ChannelInfo) {
	if el.product.prod.Len() != 5 {
		panic("Product length mismatch. Expected 5.")
	}

	el.Capacity()
	el.Status()
	el.BufferFlat()
	el.BufferInterval()
	el.Payload()

}
