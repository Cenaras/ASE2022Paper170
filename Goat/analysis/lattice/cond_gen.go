// Code generated by generate-product.go for Cond. DO NOT EDIT.

package lattice

import (
	i "Goat/utils/indenter"
)

type Cond struct {
	element
	product Product
}

func (m Cond) Cond() Cond {
	return m
}

func (w Cond) String() string {
	fields := []struct {
		name  string
		value Element
	}{
		{"Locker", w.Locker()},
	}

	strs := make([]func() string, 0, len(fields))

	for _, field := range fields {
		if !field.value.eq(field.value.Lattice().Bot()) {
			strs = append(strs, (func(name string, value Element) func() string {
				return func() string {
					return colorize.Field(name) + ": " + value.String()
				}
			})(field.name, field.value))
		}
	}

	if len(strs) == 0 {
		return colorize.Element("⊥")
	}

	return i.Indenter().Start("{").NestThunkedSep(",", strs...).End("}")
}

func (w Cond) Height() int {
	return w.product.Height()
}

func (m Cond) Eq(o Element) bool {
	checkLatticeMatch(m.lattice, o.Lattice(), "=")
	return m.eq(o)
}

func (m Cond) eq(o Element) bool {
	switch o := o.(type) {
	case Cond:
		return m.product.eq(o.product)
	case *LiftedBot:
		return false
	case *DroppedTop:
		return false
	default:
		panic(errInternal)
	}
}

func (m Cond) Geq(o Element) bool {
	checkLatticeMatch(m.lattice, o.Lattice(), "⊒")
	return m.geq(o)
}

func (m Cond) geq(o Element) bool {
	switch o := o.(type) {
	case Cond:
		return m.product.geq(o.product)
	case *LiftedBot:
		return true
	case *DroppedTop:
		return false
	default:
		panic(errInternal)
	}
}

func (m Cond) Leq(o Element) bool {
	checkLatticeMatch(m.lattice, o.Lattice(), "⊑")
	return m.leq(o)
}

func (m Cond) leq(o Element) bool {
	switch o := o.(type) {
	case Cond:
		return m.product.leq(o.product)
	case *LiftedBot:
		return false
	case *DroppedTop:
		return true
	default:
		panic(errInternal)
	}
}

func (m Cond) Join(o Element) Element {
	checkLatticeMatch(m.Lattice(), o.Lattice(), "⊔")
	return m.join(o)
}

func (m Cond) MonoJoin(o Cond) Cond {
	m.product = m.product.MonoJoin(o.product)
	return m
}

func (m Cond) join(o Element) Element {
	switch o := o.(type) {
	case Cond:
		return m.MonoJoin(o)
	case *LiftedBot:
		return m
	case *DroppedTop:
		return o
	default:
		panic(errInternal)
	}
}

func (m Cond) Meet(o Element) Element {
	checkLatticeMatch(m.lattice, o.Lattice(), "⊓")
	return m.meet(o)
}

func (m Cond) MonoMeet(o Cond) Cond {
	m.product = m.product.MonoMeet(o.product)
	return m
}

func (m Cond) meet(o Element) Element {
	switch o := o.(type) {
	case Cond:
		return m.MonoMeet(o)
	case *LiftedBot:
		return o
	case *DroppedTop:
		return m
	default:
		panic(errInternal)
	}
}

func (w Cond) Locker() Element {
	return w.product.Get(0)
}

func (w Cond) UpdateLocker(value Element) Cond {
	w.product = w.product.Update(0, value)
	return w
}

func _checkCond(el Cond) {
	if el.product.prod.Len() != 1 {
		panic("Product length mismatch. Expected 1.")
	}

	el.Locker()

}
