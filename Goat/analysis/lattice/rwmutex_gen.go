// Code generated by generate-product.go for RWMutex. DO NOT EDIT.

package lattice

import (
	i "Goat/utils/indenter"
)

type RWMutex struct {
	element
	product Product
}

func (m RWMutex) RWMutex() RWMutex {
	return m
}

func (w RWMutex) String() string {
	fields := []struct {
		name  string
		value Element
	}{
		{"Status", w.Status()},
		{"RLocks", w.RLocks()},
	}

	strs := make([]func() string, 0, len(fields))

	for _, field := range fields {
		if !field.value.eq(field.value.Lattice().Bot()) {
			strs = append(strs, (func(name string, value Element) func() string {
				return func() string {
					return colorize.Field(name) + ": " + value.String()
				}
			})(field.name, field.value))
		}
	}

	if len(strs) == 0 {
		return colorize.Element("⊥")
	}

	return i.Indenter().Start("{").NestThunkedSep(",", strs...).End("}")
}

func (w RWMutex) Height() int {
	return w.product.Height()
}

func (m RWMutex) Eq(o Element) bool {
	checkLatticeMatch(m.lattice, o.Lattice(), "=")
	return m.eq(o)
}

func (m RWMutex) eq(o Element) bool {
	switch o := o.(type) {
	case RWMutex:
		return m.product.eq(o.product)
	case *LiftedBot:
		return false
	case *DroppedTop:
		return false
	default:
		panic(errInternal)
	}
}

func (m RWMutex) Geq(o Element) bool {
	checkLatticeMatch(m.lattice, o.Lattice(), "⊒")
	return m.geq(o)
}

func (m RWMutex) geq(o Element) bool {
	switch o := o.(type) {
	case RWMutex:
		return m.product.geq(o.product)
	case *LiftedBot:
		return true
	case *DroppedTop:
		return false
	default:
		panic(errInternal)
	}
}

func (m RWMutex) Leq(o Element) bool {
	checkLatticeMatch(m.lattice, o.Lattice(), "⊑")
	return m.leq(o)
}

func (m RWMutex) leq(o Element) bool {
	switch o := o.(type) {
	case RWMutex:
		return m.product.leq(o.product)
	case *LiftedBot:
		return false
	case *DroppedTop:
		return true
	default:
		panic(errInternal)
	}
}

func (m RWMutex) Join(o Element) Element {
	checkLatticeMatch(m.Lattice(), o.Lattice(), "⊔")
	return m.join(o)
}

func (m RWMutex) MonoJoin(o RWMutex) RWMutex {
	m.product = m.product.MonoJoin(o.product)
	return m
}

func (m RWMutex) join(o Element) Element {
	switch o := o.(type) {
	case RWMutex:
		return m.MonoJoin(o)
	case *LiftedBot:
		return m
	case *DroppedTop:
		return o
	default:
		panic(errInternal)
	}
}

func (m RWMutex) Meet(o Element) Element {
	checkLatticeMatch(m.lattice, o.Lattice(), "⊓")
	return m.meet(o)
}

func (m RWMutex) MonoMeet(o RWMutex) RWMutex {
	m.product = m.product.MonoMeet(o.product)
	return m
}

func (m RWMutex) meet(o Element) Element {
	switch o := o.(type) {
	case RWMutex:
		return m.MonoMeet(o)
	case *LiftedBot:
		return o
	case *DroppedTop:
		return m
	default:
		panic(errInternal)
	}
}

func (w RWMutex) Status() FlatElement {
	return w.product.Get(0).Flat()
}

func (w RWMutex) UpdateStatus(value FlatElement) RWMutex {
	w.product = w.product.Update(0, value)
	return w
}

func (w RWMutex) RLocks() FlatElement {
	return w.product.Get(1).Flat()
}

func (w RWMutex) UpdateRLocks(value FlatElement) RWMutex {
	w.product = w.product.Update(1, value)
	return w
}

func _checkRWMutex(el RWMutex) {
	if el.product.prod.Len() != 2 {
		panic("Product length mismatch. Expected 2.")
	}

	el.Status()
	el.RLocks()

}
