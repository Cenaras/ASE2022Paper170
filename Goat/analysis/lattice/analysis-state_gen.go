// Code generated by generate-product.go for AnalysisState. DO NOT EDIT.

package lattice

import (
	i "Goat/utils/indenter"
)

type AnalysisState struct {
	element
	product Product
}

func (m AnalysisState) AnalysisState() AnalysisState {
	return m
}

func (w AnalysisState) String() string {
	fields := []struct {
		name  string
		value Element
	}{
		{"Memory", w.Memory()},
		{"Charges", w.ThreadCharges()},
	}

	strs := make([]func() string, 0, len(fields))

	for _, field := range fields {
		if !field.value.eq(field.value.Lattice().Bot()) {
			strs = append(strs, (func(name string, value Element) func() string {
				return func() string {
					return colorize.Field(name) + ": " + value.String()
				}
			})(field.name, field.value))
		}
	}

	if len(strs) == 0 {
		return colorize.Element("⊥")
	}

	return i.Indenter().Start("{").NestThunkedSep(",", strs...).End("}")
}

func (w AnalysisState) Height() int {
	return w.product.Height()
}

func (m AnalysisState) Eq(o Element) bool {
	checkLatticeMatch(m.lattice, o.Lattice(), "=")
	return m.eq(o)
}

func (m AnalysisState) eq(o Element) bool {
	switch o := o.(type) {
	case AnalysisState:
		return m.product.eq(o.product)
	case *LiftedBot:
		return false
	case *DroppedTop:
		return false
	default:
		panic(errInternal)
	}
}

func (m AnalysisState) Geq(o Element) bool {
	checkLatticeMatch(m.lattice, o.Lattice(), "⊒")
	return m.geq(o)
}

func (m AnalysisState) geq(o Element) bool {
	switch o := o.(type) {
	case AnalysisState:
		return m.product.geq(o.product)
	case *LiftedBot:
		return true
	case *DroppedTop:
		return false
	default:
		panic(errInternal)
	}
}

func (m AnalysisState) Leq(o Element) bool {
	checkLatticeMatch(m.lattice, o.Lattice(), "⊑")
	return m.leq(o)
}

func (m AnalysisState) leq(o Element) bool {
	switch o := o.(type) {
	case AnalysisState:
		return m.product.leq(o.product)
	case *LiftedBot:
		return false
	case *DroppedTop:
		return true
	default:
		panic(errInternal)
	}
}

func (m AnalysisState) Join(o Element) Element {
	checkLatticeMatch(m.Lattice(), o.Lattice(), "⊔")
	return m.join(o)
}

func (m AnalysisState) MonoJoin(o AnalysisState) AnalysisState {
	m.product = m.product.MonoJoin(o.product)
	return m
}

func (m AnalysisState) join(o Element) Element {
	switch o := o.(type) {
	case AnalysisState:
		return m.MonoJoin(o)
	case *LiftedBot:
		return m
	case *DroppedTop:
		return o
	default:
		panic(errInternal)
	}
}

func (m AnalysisState) Meet(o Element) Element {
	checkLatticeMatch(m.lattice, o.Lattice(), "⊓")
	return m.meet(o)
}

func (m AnalysisState) MonoMeet(o AnalysisState) AnalysisState {
	m.product = m.product.MonoMeet(o.product)
	return m
}

func (m AnalysisState) meet(o Element) Element {
	switch o := o.(type) {
	case AnalysisState:
		return m.MonoMeet(o)
	case *LiftedBot:
		return o
	case *DroppedTop:
		return m
	default:
		panic(errInternal)
	}
}

func (w AnalysisState) Memory() Memory {
	return w.product.Get(0).Memory()
}

func (w AnalysisState) UpdateMemory(value Memory) AnalysisState {
	w.product = w.product.Update(0, value)
	return w
}

func (w AnalysisState) ThreadCharges() ThreadCharges {
	return w.product.Get(1).ThreadCharges()
}

func (w AnalysisState) UpdateThreadCharges(value ThreadCharges) AnalysisState {
	w.product = w.product.Update(1, value)
	return w
}

func _checkAnalysisState(el AnalysisState) {
	if el.product.prod.Len() != 2 {
		panic("Product length mismatch. Expected 2.")
	}

	el.Memory()
	el.ThreadCharges()

}
