// Code generated by generate-map.go for OpOutcomes. DO NOT EDIT.

package lattice

type OpOutcomesLattice struct {
	lattice
	mp MapLattice
}

func (m *OpOutcomesLattice) Eq(o Lattice) bool {
	switch o := o.(type) {
	case *OpOutcomesLattice:
		return true
	case *Lifted:
		return m.Eq(o.Lattice)
	case *Dropped:
		return m.Eq(o.Lattice)
	default:
		return false
	}
}

func (m *OpOutcomesLattice) Top() Element {
	return OpOutcomes{
		element{m},
		m.mp.Top().Map(),
	}
}

func (m *OpOutcomesLattice) Bot() Element {
	return OpOutcomes{
		element{m},
		m.mp.Bot().Map(),
	}
}

func (m *OpOutcomesLattice) OpOutcomes() *OpOutcomesLattice {
	return m
}

type OpOutcomes struct {
	element
	mp Map
}

// Map methods
func (w OpOutcomes) Get(key string) AbstractValue {
	return w.mp.Get(key).(AbstractValue)
}

func (w OpOutcomes) Update(key string, value AbstractValue) OpOutcomes {
	w.mp = w.mp.update(key, value)
	return w
}

func (w OpOutcomes) ForEach(f func(string, AbstractValue)) {
	w.mp.ForEach(func(key interface{}, value Element) {
		f(key.(string), value.(AbstractValue))
	})
}

// Lattice element methods
func (w OpOutcomes) Leq(e Element) bool {
	checkLatticeMatch(w.lattice, e.Lattice(), "⊑")
	return w.leq(e)
}

func (w OpOutcomes) leq(e Element) bool {
	return w.mp.leq(e.(OpOutcomes).mp)
}

func (w OpOutcomes) Geq(e Element) bool {
	checkLatticeMatch(w.lattice, e.Lattice(), "⊒")
	return w.geq(e)
}

func (w OpOutcomes) geq(e Element) bool {
	return w.mp.geq(e.(OpOutcomes).mp)
}

func (w OpOutcomes) Eq(e Element) bool {
	checkLatticeMatch(w.lattice, e.Lattice(), "=")
	return w.eq(e)
}

func (w OpOutcomes) eq(e Element) bool {
	return w.mp.eq(e.(OpOutcomes).mp)
}

func (w OpOutcomes) Join(o Element) Element {
	checkLatticeMatch(w.lattice, o.Lattice(), "⊔")
	return w.join(o)
}

func (w OpOutcomes) join(o Element) Element {
	switch o := o.(type) {
	case OpOutcomes:
		return w.MonoJoin(o)
	case *LiftedBot:
		return w
	case *DroppedTop:
		return o
	default:
		panic(errInternal)
	}
}

func (w OpOutcomes) MonoJoin(o OpOutcomes) OpOutcomes {
	w.mp = w.mp.MonoJoin(o.mp)
	return w
}

func (w OpOutcomes) Meet(o Element) Element {
	checkLatticeMatch(w.lattice, o.Lattice(), "⊓")
	return w.meet(o)
}

func (w OpOutcomes) meet(o Element) Element {
	switch o := o.(type) {
	case OpOutcomes:
		return w.MonoMeet(o)
	case *LiftedBot:
		return o
	case *DroppedTop:
		return w
	default:
		panic(errInternal)
	}
}

func (w OpOutcomes) MonoMeet(o OpOutcomes) OpOutcomes {
	w.mp = w.mp.MonoMeet(o.mp)
	return w
}

func (w OpOutcomes) String() string {
	return w.mp.String()
}

// Type conversion
func (w OpOutcomes) OpOutcomes() OpOutcomes {
	return w
}
